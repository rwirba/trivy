---
# Validate inputs on control node before touching targets
- name: Ensure local tarball exists (control node)
  delegate_to: localhost
  run_once: true
  ansible.builtin.stat:
    path: "{{ trivy_db_tar_local }}"
  register: _db_local

- name: Ensure local scan script exists (control node)
  delegate_to: localhost
  run_once: true
  ansible.builtin.stat:
    path: "{{ scan_script_local }}"
  register: _script_local

- name: Abort if inputs missing
  delegate_to: localhost
  run_once: true
  ansible.builtin.assert:
    that:
      - _db_local.stat.exists
      - _script_local.stat.exists
    fail_msg: >-
      One or more inputs missing on control node.
      DB: {{ trivy_db_tar_local }} exists={{ _db_local.stat.exists }},
      Script: {{ scan_script_local }} exists={{ _script_local.stat.exists }}

# Work on target
- name: Ensure staging/cache/report directories on target
  become: true
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ trivy_target_user }}"
    group: "{{ trivy_target_user }}"
    mode: "0755"
  loop:
    - "{{ trivy_stage_dir }}"
    - "{{ trivy_cache_dir }}"
    - "{{ trivy_db_dir }}"
    - "{{ trivy_reports_root }}"

- name: Copy offline DB tarball to target
  ansible.builtin.copy:
    src: "{{ trivy_db_tar_local }}"
    dest: "{{ trivy_db_tar_remote }}"
    mode: "0644"

- name: Extract DB into Trivy cache (~/.cache/trivy)
  ansible.builtin.unarchive:
    src: "{{ trivy_db_tar_remote }}"
    dest: "{{ trivy_cache_dir }}"
    remote_src: true
    owner: "{{ trivy_target_user }}"
    group: "{{ trivy_target_user }}"
    creates: "{{ trivy_db_dir }}/trivy.db"

- name: Verify trivy.db exists after extraction
  ansible.builtin.stat:
    path: "{{ trivy_db_dir }}/trivy.db"
  register: _db_ok

- name: Verify metadata.json exists after extraction
  ansible.builtin.stat:
    path: "{{ trivy_db_dir }}/metadata.json"
  register: _meta_ok

- name: Fail if offline DB files missing
  ansible.builtin.fail:
    msg: "Offline DB incomplete under {{ trivy_db_dir }} (need trivy.db and metadata.json)."
  when: not _db_ok.stat.exists or not _meta_ok.stat.exists

- name: Ensure /usr/local/bin exists
  become: true
  ansible.builtin.file:
    path: /usr/local/bin
    state: directory
    mode: "0755"

- name: Install scan script on target
  become: true
  ansible.builtin.copy:
    src: "{{ scan_script_local }}"
    dest: "{{ scan_script_remote }}"
    owner: root
    group: root
    mode: "0755"

# NEW â€” make rootless Podman visible to Trivy
- name: Get UID of scan user
  become: true
  ansible.builtin.command: id -u {{ trivy_target_user }}
  register: _uid
  changed_when: false

- name: Allow user services to run (linger)
  become: true
  ansible.builtin.command: loginctl enable-linger {{ trivy_target_user }}
  changed_when: false

- name: Enable and start Podman user socket
  become: true
  become_user: "{{ trivy_target_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ _uid.stdout }}"
  ansible.builtin.command: systemctl --user enable --now podman.socket
  register: _podman_socket
  failed_when: false
  changed_when: false

- name: Run offline scan (generates timestamped report dir)
  become: true
  become_user: "{{ trivy_target_user }}"
  environment:
    SEVERITY: "{{ severity }}"
    CACHE_DIR: "{{ trivy_cache_dir }}"
    TRIVY_IMAGE_SRC: "podman"
    TRIVY_SKIP_DB_UPDATE: "true"
    TRIVY_SKIP_JAVA_DB_UPDATE: "true"
    TRIVY_OFFLINE_SCAN: "true"
    XDG_RUNTIME_DIR: "/run/user/{{ _uid.stdout }}"
  ansible.builtin.shell: "{{ scan_script_remote }}"
  args:
    chdir: "{{ trivy_reports_root }}"
  register: _scan
  failed_when: false

- name: Show scan script output (for quick visibility)
  ansible.builtin.debug:
    var: _scan.stdout_lines

- name: Parse reports dir from stdout (robust)
  ansible.builtin.set_fact:
    reports_dir: >-
      {{ (
           _scan.stdout_lines
           | select('search', 'Reports saved to:')
           | list
           | last
           | default('')
           | regex_replace('^.*Reports saved to:\\s*', '')
         ) }}

- name: Fallback to newest reports dir if not parsed
  when: reports_dir | length == 0
  ansible.builtin.shell: |
    ls -1dt {{ trivy_reports_root }}/trivy-reports-* 2>/dev/null | head -n1
  args: { executable: /bin/bash }
  register: _latest_dir
  changed_when: false

- name: Use newest reports dir (fallback)
  when: reports_dir | length == 0
  ansible.builtin.set_fact:
    reports_dir: "{{ _latest_dir.stdout | default('', true) }}"

- name: Verify reports dir exists on remote
  ansible.builtin.stat:
    path: "{{ reports_dir }}"
  register: _repdir

- name: Fail if no report directory was produced
  ansible.builtin.fail:
    msg: "No report directory found under {{ trivy_reports_root }}."
  when: reports_dir | length == 0 or not _repdir.stat.exists

- name: List JSON reports on remote
  ansible.builtin.find:
    paths: "{{ reports_dir }}"
    patterns: "*.json"
    file_type: file
  register: _report_files

- name: Fetch reports back to control node
  when: _report_files.files | length > 0
  ansible.builtin.fetch:
    src: "{{ item.path }}"
    dest: "reports/{{ inventory_hostname }}/"
    flat: true
  loop: "{{ _report_files.files }}"


# --- Fetch reports from remote properly (robust) ---
- name: Parse reports dir from stdout (robust)
  ansible.builtin.set_fact:
    _reports_dir: >-
      {{
        (
          _scan.stdout_lines
          | select('search', 'Reports saved to:')
          | list
          | last
          | default('')
          | regex_replace('^.*Reports saved to:\\s*', '')
        )
      }}

- name: Fallback to newest reports dir if not parsed
  when: _reports_dir | length == 0
  ansible.builtin.shell: |
    ls -1dt {{ trivy_reports_root }}/trivy-reports-* 2>/dev/null | head -n1
  args:
    executable: /bin/bash
  register: _latest_dir
  changed_when: false

- name: Use newest reports dir (fallback)
  when: _reports_dir | length == 0
  ansible.builtin.set_fact:
    _reports_dir: "{{ _latest_dir.stdout | default('', true) }}"

- name: Verify reports dir exists on remote
  ansible.builtin.stat:
    path: "{{ _reports_dir }}"
  register: _repdir

- name: Fail if no report directory was produced
  ansible.builtin.fail:
    msg: "No report directory found under {{ trivy_reports_root }}."
  when: _reports_dir | length == 0 or not _repdir.stat.exists

- name: List JSON reports on remote
  ansible.builtin.find:
    paths: "{{ _reports_dir }}"
    patterns: "*.json"
    file_type: file
  register: _report_files

- name: Fetch reports back to control node
  when: _report_files.files | length > 0
  ansible.builtin.fetch:
    src: "{{ item.path }}"
    dest: "reports/{{ inventory_hostname }}/"
    flat: true
  loop: "{{ _report_files.files }}"

