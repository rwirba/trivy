---
# Validate inputs on control node before touching targets
- name: Ensure local tarball exists (control node)
  delegate_to: localhost
  run_once: true
  ansible.builtin.stat:
    path: "{{ trivy_db_tar_local }}"
  register: _db_local

- name: Ensure local scan script exists (control node)
  delegate_to: localhost
  run_once: true
  ansible.builtin.stat:
    path: "{{ scan_script_local }}"
  register: _script_local

- name: Abort if inputs missing
  delegate_to: localhost
  run_once: true
  ansible.builtin.assert:
    that:
      - _db_local.stat.exists
      - _script_local.stat.exists
    fail_msg: >-
      One or more inputs missing on control node.
      DB: {{ trivy_db_tar_local }} exists={{ _db_local.stat.exists }},
      Script: {{ scan_script_local }} exists={{ _script_local.stat.exists }}

# Work on target
- name: Ensure staging/cache/report directories on target
  become: true
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    owner: "{{ trivy_target_user }}"
    group: "{{ trivy_target_user }}"
    mode: "0755"
  loop:
    - "{{ trivy_stage_dir }}"
    - "{{ trivy_cache_dir }}"
    - "{{ trivy_db_dir }}"
    - "{{ trivy_reports_root }}"

- name: Copy offline DB tarball to target
  ansible.builtin.copy:
    src: "{{ trivy_db_tar_local }}"
    dest: "{{ trivy_db_tar_remote }}"
    mode: "0644"

- name: Extract DB into Trivy cache (~/.cache/trivy)
  ansible.builtin.unarchive:
    src: "{{ trivy_db_tar_remote }}"
    dest: "{{ trivy_cache_dir }}"
    remote_src: true
    owner: "{{ trivy_target_user }}"
    group: "{{ trivy_target_user }}"
    creates: "{{ trivy_db_dir }}/trivy.db"

- name: Verify trivy.db exists after extraction
  ansible.builtin.stat:
    path: "{{ trivy_db_dir }}/trivy.db"
  register: _db_ok

- name: Verify metadata.json exists after extraction
  ansible.builtin.stat:
    path: "{{ trivy_db_dir }}/metadata.json"
  register: _meta_ok

- name: Fail if offline DB files missing
  ansible.builtin.fail:
    msg: "Offline DB incomplete under {{ trivy_db_dir }} (need trivy.db and metadata.json)."
  when: not _db_ok.stat.exists or not _meta_ok.stat.exists

- name: Ensure /usr/local/bin exists
  become: true
  ansible.builtin.file:
    path: /usr/local/bin
    state: directory
    mode: "0755"

- name: Install scan script on target
  become: true
  ansible.builtin.copy:
    src: "{{ scan_script_local }}"
    dest: "{{ scan_script_remote }}"
    owner: root
    group: root
    mode: "0755"

- name: Run offline scan (generates timestamped report dir)
  become: true
  become_user: "{{ trivy_target_user }}"
  environment:
    SEVERITY: "{{ severity }}"
    CACHE_DIR: "{{ trivy_cache_dir }}"
  ansible.builtin.shell: "{{ scan_script_remote }}"
  args:
    chdir: "{{ trivy_reports_root }}"
  register: _scan
  failed_when: false

- name: Show scan script output (for quick visibility)
  ansible.builtin.debug:
    var: _scan.stdout_lines

# --- Fetch reports from remote properly ---
- name: Derive reports directory from output (fallback to newest)
  ansible.builtin.set_fact:
    _reports_dir: >-
      {{ (_scan.stdout | regex_search('Reports saved to:\\s*(\\S+)', '\\1')) |
         default(lookup('pipe', 'ls -1dt ' ~ trivy_reports_root ~ '/trivy-reports-* 2>/dev/null | head -n1'), true) }}

- name: Verify reports dir exists on remote
  ansible.builtin.stat:
    path: "{{ _reports_dir }}"
  register: _repdir

- name: Fail if no report directory was produced
  ansible.builtin.fail:
    msg: "No report directory found under {{ trivy_reports_root }}."
  when: _reports_dir | length == 0 or not _repdir.stat.exists

- name: List JSON reports on remote
  ansible.builtin.find:
    paths: "{{ _reports_dir }}"
    patterns: "*.json"
    file_type: file
  register: _report_files

- name: Fetch reports back to control node
  when: _report_files.files | length > 0
  ansible.builtin.fetch:
    src: "{{ item.path }}"
    dest: "reports/{{ inventory_hostname }}/"
    flat: true
  loop: "{{ _report_files.files }}"
